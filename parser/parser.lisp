(uiop:define-package :translator/parser/parser
    (:use :cl :alexandria
          :common)
  (:export #:parser))

(in-package :translator/parser/parser)

(defun parser (lexems)
  (let (current-lexem)
    (labels ((%scan ()
               (setf current-lexem (car lexems))
               (setf lexems (cdr lexems)))
             (%err (str)
               (break "Error: ~A~%Got: ~A~%   At line: ~A, column: ~A"
                      str
                      (value current-lexem)
                      (line current-lexem)
                      (column current-lexem))
               (return-from parser))
             (%is-keyword (keyword)
               (let ((val (value current-lexem)))
                 (and (gethash val *keywords*)
                      (eq val keyword))))
             (%is-code (code)
               (eq (code current-lexem) code))

             (%program ()
               (unless (%is-keyword :program)
                 (%err "'PROGRAM' expected"))
               (%scan)
               (let ((name (%proc-id)))
                 (unless name
                   (%err "Procedure identifier expected"))
                 (%scan)
                 (unless (%is-code 59)
                   (%err "';' expected"))
                 (%scan)
                 (let ((body (%block)))
                   (%scan)
                   (unless (%is-code 46)
                     (%err "'.' expected"))
                   (list :program name body))))
             (%block ()
               (let ((var-decls (%var-decls)))
                 (unless (%is-keyword :begin)
                   (%err "'BEGIN' expected"))
                 (%scan)
                 (let ((stmt-list (%stmt-list)))
                   (unless (%is-keyword :end)
                     (%err "'END' expected"))
                   (list :block var-decls stmt-list))))
             (%var-decls ()
               (when (%is-keyword :var)
                 (%scan)
                 (awhen (%decl-list)
                   (list :var-decls it))))
             (%decl-list ()
               (labels ((%helper ()
                          (awhen (%decl)
                            (%scan)
                            (cons it (%helper)))))
                 (aif (%helper)
                      (list :decl-list it)
                      (list :decl-list))))
             (%decl ()
               (awhen (%var-id)
                 (%scan)
                 (unless (%is-code 58)
                   (%err "':' expected"))
                 (%scan)
                 (let ((attr (%attr)))
                   (%scan)
                   (unless (%is-code 59)
                     (%err "';' expected"))
                   (list :decl it attr))))
             (%attr ()
               (unless (or (%is-keyword :integer)
                           (%is-keyword :float))
                 (%err "Attribute expected"))
               (list :attr (string (value current-lexem))))
             (%stmt-list ()
               (labels ((%helper ()
                          (awhen (%stmt)
                            (%scan)
                            (cons it (%helper)))))
                 (aif (%helper)
                      (list :stmt-list it)
                      (list :stmt-list))))
             (%stmt ()
               (when (%is-keyword :while)
                 (%scan)
                 (let ((cond-expr (%cond-expr)))
                   (%scan)
                   (unless (%is-keyword :do)
                     (%err "'DO' expected"))
                   (%scan)
                   (let ((stmt-l (%stmt-list)))
                     (unless (%is-keyword :endwhile)
                       (%err "'ENDWHILE' expected"))
                     (%scan)
                     (unless (%is-code 59)
                       (%err "';' expected"))
                     (list :stmt (list :while cond-expr stmt-l))))))
             (%cond-expr ()
               (let ((expr (%expr)))
                 (%scan)
                 (let ((comp-op (%comp-op)))
                   (%scan)
                   (list :cond-expr expr comp-op (%expr)))))
             (%comp-op ()
               (let ((comp-op (or (eq (get-lexem-type current-lexem)
                                      :multichar-delimiter)
                                  (%is-code 60)
                                  (%is-code 61)
                                  (%is-code 62))))
                 (unless comp-op
                   (%err "Comparison operator expected"))
                 (list :comp-op (string (value current-lexem)))))
             (%expr ()
               (let ((expr (or (%var-id)
                               (%uint))))
                 (unless expr
                   (%err "Variable identifier or unsigned integer expected"))
                 (list :expr expr)))
             (%var-id ()
               (awhen (%id)
                 (list :var-id it)))
             (%proc-id ()
               (awhen (%id)
                 (list :proc-id it)))
             (%id ()
               (and (eq (get-lexem-type current-lexem) :identifier)
                    (list :id (string (value current-lexem)))))
             (%uint ()
               (and (eq (get-lexem-type current-lexem) :constant)
                    (list :uint (value current-lexem)))))
      (%scan)
      (prog1
          (%program)
        (%scan)
        (when current-lexem
          (%err "End of file expected"))))))

