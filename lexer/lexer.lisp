(uiop:define-package :translator/lexer/lexer
    (:use :cl :alexandria :translator/common/common)
  (:export #:lexer))

(in-package :translator/lexer/lexer)

(defun convert-to-symbols (string-list)
  (mapcar (rcurry #'intern :keyword) string-list))

(defun lexer (stream)
  "Returns list of tokens"
  (let ((symbol)
        (current-lexem)
        (lexems)
        (line 1)
        (lexem-column 1)
        (column 0))
    ;; Initialize hash tables
    (let ((delimiters '("<=" "<>" ">="))
          (delimiters-counter 300))
      (mapc (lambda (delimiter)
              (setf (gethash delimiter *mc-delimiters*) (incf delimiters-counter)))
            delimiters))

    (let ((keywords (convert-to-symbols '("PROGRAM"
                                          "BEGIN"
                                          "END"
                                          "VAR"
                                          "INTEGER"
                                          "FLOAT"
                                          "WHILE"
                                          "DO"
                                          "ENDWHILE")))
          (keywords-counter 400))
      (mapc (lambda (keyword)
              (setf (gethash keyword *keywords*) (incf keywords-counter)))
            keywords))

    (let ((identifiers '())
          (identifiers-counter 1000)
          (constants-counter 500))
      (mapc (lambda (identifier)
              (setf (gethash identifier *identifiers*) (incf identifiers-counter)))
            identifiers)

      (labels ((%scan ()
                 (incf column)
                 (setf symbol (read-char stream nil 'eof)))
               (%update-lexem ()
                 (push symbol current-lexem))
               (%update-lexem-pos ()
                 (setf lexem-column column))
               (%is-newline ()
                 (= (char-code symbol) 10))
               (%newline ()
                 (setf column 0)
                 (incf line))
               (%newline? ()
                 (when (%is-newline)
                   (%newline)))
               (%eof? ()
                 (when (eq symbol 'eof)
                   (%error "Unexpected end of file")))
               (%smart-scan ()
                 "Returns t because of specialized usage in `%com'"
                 (%scan)
                 (%eof?)
                 (%newline?)
                 t)
               (%number ()
                 (%update-lexem-pos)
                 (%update-lexem)
                 (loop for symbol = (%scan)
                    while (= (aref *symbol-categories* (char-code symbol)) 1)
                    do
                      (%update-lexem))
                 (%out :is-constant t))
               (%identifier ()
                 (%update-lexem-pos)
                 (%update-lexem)
                 (loop for symbol = (%scan)
                    while (member (aref *symbol-categories* (char-code symbol)) '(1 2))
                    do
                      (%update-lexem))
                 (%out :is-identifier t))
               (%dm1 ()
                 (%update-lexem-pos)
                 (%update-lexem)
                 (%out)
                 (incf lexem-column)
                 (%scan))
               (%dm2 ()
                 (%update-lexem-pos)
                 (%update-lexem)
                 (%scan)
                 (when (member (char-code symbol) '(61 62))
                   (%update-lexem))
                 (%out)
                 (%newline?)
                 (%scan))
               (%dm3 ()
                 (%update-lexem-pos)
                 (%update-lexem)
                 (%scan)
                 (when (= (char-code symbol) 61)
                   (%update-lexem))
                 (%out)
                 (%newline?)
                 (%scan))
               (%com ()
                 (%scan)
                 (%eof?)
                 (unless (= (char-code symbol) 42)
                   (%error "'*' expected"))
                 (let (ecom)
                   (do ()
                       ((and ecom (%smart-scan) (= (char-code symbol) 41))
                        (%scan))
                     (unless ecom
                       (%smart-scan))
                     (case (char-code symbol)
                       (42 (setf ecom t))
                       (otherwise (setf ecom nil))))))
               (%out (&key (is-identifier nil) (is-constant nil))
                 (let* ((value_ (coerce (reverse current-lexem) 'string))
                        (value
                         (cond (is-identifier (intern value_ :keyword))
                               (is-constant (parse-integer value_))
                               (t value_))))
                   (push (make-instance 'lexem
                                        :value value
                                        :line line
                                        :column lexem-column
                                        :code (or (gethash value *mc-delimiters*)
                                                  (and (numberp value)
                                                       (or (gethash value *constants*)
                                                           (setf (gethash value *constants*) (incf constants-counter))))
                                                  (and (stringp value)
                                                       (char-code (char value 0)))
                                                  (gethash value *keywords*
                                                           (gethash value *identifiers*))
                                                  (setf (gethash value *identifiers*) (incf identifiers-counter))))
                         lexems))
                 (setf lexem-column column)
                 (setf current-lexem nil))
               (%error (message)
                 (break "Error occurred:~%  ~A~%Line: ~A, column: ~A" message line column)
                 (return-from lexer (reverse lexems))))

        (%scan)
        (do ()
            ((eq symbol 'eof))
          (case (aref *symbol-categories* (char-code symbol))
            (0 (%newline?)
               (%scan)
               (setf lexem-column column))
            (1 (%number))
            (2 (%identifier))
            (3 (%dm1))
            (41 (%dm2))
            (42 (%dm3))
            (51 (%com))
            (6 (%error (format nil "Unallowed character detected: ~A" symbol)))
            (otherwise (%error "Unexpected error"))))
        (reverse lexems)))))
